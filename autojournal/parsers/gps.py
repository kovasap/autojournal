"""Gps data parsing functionality.

Parses data generated by the GPSLogger for Android app (https://gpslogger.app/).
Make sure that "gps" is the only source for data on the app (not "network").
"""

from dataclasses import dataclass
from dateutil import tz
from datetime import datetime
from typing import List, Tuple, Sequence
import statistics

import geopy.distance
import geopy.geocoders

from ..data_model import Event

# Distance between two readings for movement between them to be ignored.
STATIONARY_DISTANCE_MILES = 0.1
STATIONARY_TIME_BETWEEN_TRIPS_SECS = 60 * 5

location_bank = []
nominatim = geopy.geocoders.Nominatim(user_agent='autojournal')

def make_float(s: str) -> float:
  return float(s) if s else 0.0

@dataclass
class Location:
  """Stores location data."""

  latitude: float
  longitude: float
  elevation: float
  accuracy_miles: float
  speed: float
  name: str = 'unknown'
  mode_of_travel: str = None

  @classmethod
  def from_line(cls, line: dict) -> 'Location':
    return cls(
        latitude=make_float(line['lat']),
        longitude=make_float(line['lon']),
        elevation=make_float(line['elevation']),
        accuracy_miles=make_float(line['accuracy']) / 1609.34,  # meters -> miles
        speed=make_float(line['speed']))

  def summary(self) -> str:
    if self.mode_of_travel:
      return ''
    else:
      if self.name == 'unknown':
        self.lookup_name()
      return f'At {self.name}'

  def as_point(self) -> Tuple[float, float]:
    return (self.latitude, self.longitude)

  def get_distance(self, other):
    return geopy.distance.distance(
        self.as_point(), other.as_point()).miles

  def is_same_place(self, other) -> bool:
    return (
        self.accuracy_miles + other.accuracy_miles + STATIONARY_DISTANCE_MILES
        > self.get_distance(other))

  def lookup_name(self) -> str:
    for banked_location in location_bank:
      if banked_location.is_same_place(self):
        self.name = banked_location.name
    else:
      self.name = nominatim.reverse(self.as_point()).address
      location_bank.append(self)

  def __str__(self) -> str:
    return f'{self.as_point()}, {self.name}'


def get_traveling_description(
    timestamps: Sequence[datetime], locations: Sequence[Location]) -> str:
  mph_speeds = [
      locations[i-1].get_distance(location)
      / ((timestamp - timestamps[i-1]).total_seconds() / 60 / 60)
      for i, (timestamp, location) in enumerate(zip(timestamps, locations))
      if i > 0
  ]
  if not mph_speeds:
    return 'not enough data'
  average_mph_speed = statistics.mean(mph_speeds)
  stdev_mph_speed = statistics.stdev(mph_speeds)
  max_mph_speed = max(mph_speeds)
  # https://www.bbc.co.uk/bitesize/guides/zq4mfcw/revision/1
  if average_mph_speed < 2:
    mode_of_travel = 'not travelling?'
  elif average_mph_speed < 4 and max_mph_speed < 7:
    mode_of_travel = 'walking'
  elif average_mph_speed < 13 and max_mph_speed < 16:
    mode_of_travel = 'running'
  elif average_mph_speed < 25:
    mode_of_travel = 'biking'
  elif average_mph_speed < 100:
    mode_of_travel = 'driving'
  elif average_mph_speed < 300:
    mode_of_travel = 'on the train'
  else:
    mode_of_travel = 'flying'
  return (f'{mode_of_travel} at {average_mph_speed:.2f}Â±{stdev_mph_speed:.2f} '
          f'mph (max of {max_mph_speed:.2f} mph)')


def make_calendar_event(
    timestamps: Sequence[datetime], locations: Sequence[Location],
    travel_event: bool) -> Event:
  return Event(
      timestamp=timestamps[0],
      duration=timestamps[-1] - timestamps[0],
      summary=(get_traveling_description(timestamps, locations)
               if travel_event else locations[-1].summary()),
      description='')


def find_breakpoints(locations: List[Location], num_buffer_points: int=6):
  """Finds sections of input list where location is different."""
  assert num_buffer_points % 2 == 0
  transitions_to_travel = set()
  transitions_to_stationary = set()
  were_travelling = False
  for i, _ in enumerate(locations):
    if i < num_buffer_points:
      continue
    buffer_locations = [locations[i + j - num_buffer_points]
                        for j in range(num_buffer_points)]
    # If we are in a different place num_buffer_points/2 later, we are
    # travelling.
    currently_travelling = all(
        not buffer_locations[j].is_same_place(
            buffer_locations[j + (num_buffer_points // 2)])
        for j in range(len(buffer_locations) // 2))
    if not were_travelling and currently_travelling:
      transitions_to_travel.add(i - (num_buffer_points // 2))
      were_travelling = True
    elif were_travelling and not currently_travelling:
      transitions_to_stationary.add(i - (num_buffer_points // 2))
      were_travelling = False
  return transitions_to_travel, transitions_to_stationary


def parse_gps(data_by_fname) -> List[Event]:
  event_timestamps = []
  event_locations = []
  events = []
  for fname, data in sorted(data_by_fname.items(), key=lambda t: t[0]):
    if not fname.endswith('.zip'):
      continue
    line_locations = []
    line_timestamps = []
    for line in data:
      line_locations.append(Location.from_line(line))
      line_timestamps.append(datetime.fromisoformat(
          line['time'].replace('Z', '+00:00')).astimezone(tz.gettz('PST')))
    transitions_to_travel, transitions_to_stationary = find_breakpoints(
        line_locations)
    print(transitions_to_travel, transitions_to_stationary)
    for i, (location, timestamp) in enumerate(zip(line_locations, line_timestamps)):
      if i > 0:
        # if location.speed > 0:
        print(
            # .replace(tzinfo=tz.gettz('PST'))
            timestamp.strftime('%m/%d/%Y %I:%M%p'),
            # str(line_location),
            round(location.speed * 2.236, 2),  # m/s -> mph
            round(line_locations[i-1].get_distance(location), 2),
            line_locations[i-1].is_same_place(location),
            'travel' if i in transitions_to_travel else '',
            'station' if i in transitions_to_stationary else '')
      # If we were traveling, and now are not (or vice versa), we create a new
      # event and reset our event lists.
      if i > 0 and (i in transitions_to_travel or i in transitions_to_stationary):
        events.append(make_calendar_event(event_timestamps, event_locations,
                                          i in transitions_to_stationary))
        event_timestamps = []
        event_locations = []
      event_timestamps.append(timestamp)
      event_locations.append(location)
  events.append(make_calendar_event(event_timestamps, event_locations, False))
  return events
